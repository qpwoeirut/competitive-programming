#include <bits/stdc++.h>

using namespace std;

constexpr float EPS = 1e-12;

constexpr float PASS_PRELIM_GOOD = 0.8;
constexpr float PASS_PRELIM_BAD = 0.2;
constexpr float PASS_GOOD_FULL = 0.9;
constexpr float PASS_BAD_FULL = 0.1;

constexpr int PRELIM_TIME = 20;
constexpr int FULL_TIME = 60;
constexpr int ACCEPT_TIME = 5;

mt19937 rng(8);  // technically we should also use uniform_int_distribution but should be close enough

class Interactor {  // whipping out the C++ abstract classes
public:
    Interactor(int _n) {
        n = _n;
        assert(n <= 100);

        time_spent = 0;
        idx = 0;
        selected = vector<int>();
    }
    virtual void reject() = 0;
    virtual int prelim() = 0;
    virtual int full() = 0;
    virtual void accept() = 0;
    virtual int get_k() = 0;
    virtual bool selected_ok() = 0;

    int n;
    int time_spent;
    int idx;
    vector<int> selected;

    float score() {
        assert(idx == n);
        const int g = (int)selected.size();
        if (g < 5) return 0;
        if (!selected_ok()) return 0;

        const int r = selected.back() - selected[0];
        return 100000.0 * floor(g * sqrt(sqrt(g))) / ((time_spent + 10) * (n - r) + 10);
    }
    int min_selected() {
        return selected.empty() ? n : selected[0];
    }
    int max_selected() {
        return selected.empty() ? -1 : selected.back();
    }
};

class SelfInteractor : public Interactor {
private:
    bitset<100> good;
public:
    SelfInteractor(int _n) : Interactor(_n) {
        vector<unsigned> p(n);
        for (int i = 0; i < n; ++i) {
            p[i] = rng() % 61;
        }
        sort(p.begin(), p.end());

        for (int i = 0; i < n; ++i) {
            good[i] = (rng() % 100) < p[i];
        }

        set<int> bad;
        while (bad.size() < 10) bad.insert(rng() % 100);
        for (int i: bad) {
            good[i] = false;
        }
    }
    void reject() {
        ++idx;
    }
    int prelim() {
        time_spent += PRELIM_TIME;

        const unsigned p_prelim = (unsigned)((good[idx] ? PASS_PRELIM_GOOD : PASS_PRELIM_BAD) * 10 + EPS);
        if (rng() % 10 < p_prelim) {
            return full();
        } else {
            ++idx;
            return 0;
        }
    }
    int full() {
        time_spent += FULL_TIME;

        const unsigned p_full = (unsigned)((good[idx] ? PASS_GOOD_FULL : PASS_BAD_FULL) * 10 + EPS);
        if (rng() % 10 < p_full) {
            selected.push_back(idx);
            ++idx;
            return 2;
        } else {
            ++idx;
            return 1;
        }
    }
    void accept() {
        time_spent += ACCEPT_TIME;

        selected.push_back(idx);
        ++idx;
    }
    int get_k() {
        if (idx != 50) {
            cerr << "WARNING: get_k called with idx=" << idx << endl;
        }
        int k = 0;
        for (int i = 0; i < n / 2; ++i) {
            k += !good[i];
        }
        return k;
    }
    bool selected_ok() {
        for (int s_idx: selected) {
            if (!good[s_idx]) return false;
        }
        return true;
    }
};

class GraderInteractor : public Interactor {
public:
    GraderInteractor(int _n) : Interactor(_n) {}
    void reject() {
        cout << 0 << endl;

        ++idx;
    }
    int prelim() {
        time_spent += PRELIM_TIME;

        cout << 1 << endl;

        string s;
        cin >> s;
        assert(cin.good());
        assert(s == "pass" || s == "fail");
        if (s != "pass") {
            ++idx;
            return 0;
        } else {
            time_spent += FULL_TIME;

            cin >> s;
            assert(s == "pass" || s == "fail");
            if (s != "pass") {
                ++idx;
                return 1;
            } else {
                selected.push_back(idx);
                ++idx;
                return 2;
            }
        }
    }
    int full() {
        time_spent += FULL_TIME;

        cout << 2 << endl;

        string s;
        cin >> s;
        assert(s == "pass" || s == "fail");
        assert(cin.good());
        if (s != "pass") {
            ++idx;
            return 1;
        } else {
            selected.push_back(idx);
            ++idx;
            return 2;
        }
    }
    void accept() {
        time_spent += ACCEPT_TIME;

        cout << 3 << endl;

        selected.push_back(idx);
        ++idx;
    }
    int get_k() {
        int k;
        cin >> k;
        assert(cin.good());
        return k;
    }
    bool selected_ok() {
        return true;  // we don't know, so just assume it's fine. this score won't be used anyway.
    }
};

constexpr int MN = 100;
constexpr int G_POW[MN + 1] = {  // floor(g * sqrt(sqrt(g)))
    0,
    1, 2, 3, 5, 7, 9, 11, 13, 15, 17,
    20, 22, 24, 27, 29, 32, 34, 37, 39, 42,
    44, 47, 50, 53, 55, 58, 61, 64, 67, 70,
    73, 76, 79, 82, 85, 88, 91, 94, 97, 100,
    103, 106, 110, 113, 116, 119, 123, 126, 129, 132,
    136, 139, 143, 146, 149, 153, 156, 160, 163, 166,
    170, 173, 177, 181, 184, 188, 191, 195, 198, 202,
    206, 209, 213, 217, 220, 224, 228, 231, 235, 239,
    243, 246, 250, 254, 258, 261, 265, 269, 273, 277,
    281, 284, 288, 292, 296, 300, 304, 308, 312, 316
};
constexpr float SCORE_NUMER[MN + 1] = {
    0.0,
    20000.0, 40000.0, 60000.0, 100000.0, 140000.0, 180000.0, 220000.0, 260000.0, 300000.0, 340000.0,
    400000.0, 440000.0, 480000.0, 540000.0, 580000.0, 640000.0, 680000.0, 740000.0, 780000.0, 840000.0,
    880000.0, 940000.0, 1000000.0, 1060000.0, 1100000.0, 1160000.0, 1220000.0, 1280000.0, 1340000.0, 1400000.0,
    1460000.0, 1520000.0, 1580000.0, 1640000.0, 1700000.0, 1760000.0, 1820000.0, 1880000.0, 1940000.0, 2000000.0,
    2060000.0, 2120000.0, 2200000.0, 2260000.0, 2320000.0, 2380000.0, 2460000.0, 2520000.0, 2580000.0, 2640000.0,
    2720000.0, 2780000.0, 2860000.0, 2920000.0, 2980000.0, 3060000.0, 3120000.0, 3200000.0, 3260000.0, 3320000.0,
    3400000.0, 3460000.0, 3540000.0, 3620000.0, 3680000.0, 3760000.0, 3820000.0, 3900000.0, 3960000.0, 4040000.0,
    4120000.0, 4180000.0, 4260000.0, 4340000.0, 4400000.0, 4480000.0, 4560000.0, 4620000.0, 4700000.0, 4780000.0,
    4860000.0, 4920000.0, 5000000.0, 5080000.0, 5160000.0, 5220000.0, 5300000.0, 5380000.0, 5460000.0, 5540000.0,
    5620000.0, 5680000.0, 5760000.0, 5840000.0, 5920000.0, 6000000.0, 6080000.0, 6160000.0, 6240000.0, 6320000.0
};

/*
def prob(x, r, n, k):
    p = (x + 1) / (n + 1)
    if p >= 1:
        return 1
    if p <= 0:
        return 0
    return sum([comb(k, i) * p**i * (1-p)**(k-i) for i in range(r, k+1)])
def values(n, k):
    return [sum([(prob(x, r, n, k) - prob(x - 1, r, n, k)) * x for x in range(n + 1)]) for r in range(1, k+1)]
*/
constexpr array<float, MN> EXPECTED_P = {
    0.234969473, 0.7184972322, 1.3077802518, 1.9147896048, 2.5199108525, 3.1238354433, 3.7277245241, 4.3316791979, 4.9356430594, 5.539604129, 
    6.1435643999, 6.7475247476, 7.3514851458, 7.9554455446, 8.5594059407, 9.1633663366, 9.7673267327, 10.3712871287, 10.9752475248, 11.5792079208, 
    12.1831683168, 12.7871287129, 13.3910891089, 13.995049505, 14.599009901, 15.202970297, 15.8069306931, 16.4108910891, 17.0148514851, 17.6188118812, 
    18.2227722772, 18.8267326733, 19.4306930693, 20.0346534653, 20.6386138614, 21.2425742574, 21.8465346535, 22.4504950495, 23.0544554455, 23.6584158416, 
    24.2623762376, 24.8663366337, 25.4702970297, 26.0742574257, 26.6782178218, 27.2821782178, 27.8861386139, 28.4900990099, 29.0940594059, 29.698019802, 
    30.301980198, 30.9059405941, 31.5099009901, 32.1138613861, 32.7178217822, 33.3217821782, 33.9257425743, 34.5297029703, 35.1336633663, 35.7376237624, 
    36.3415841584, 36.9455445545, 37.5495049505, 38.1534653465, 38.7574257426, 39.3613861386, 39.9653465347, 40.5693069307, 41.1732673267, 41.7772277228, 
    42.3811881188, 42.9851485149, 43.5891089109, 44.1930693069, 44.797029703, 45.400990099, 46.004950495, 46.6089108911, 47.2128712871, 47.8168316832, 
    48.4207920792, 49.0247524752, 49.6287128713, 50.2326732673, 50.8366336634, 51.4405940593, 52.0445544554, 52.6485148542, 53.2524752524, 53.8564356001, 
    54.460395871, 55.0643569406, 55.6683208021, 56.2722754759, 56.8761645567, 57.4800891475, 58.0852103952, 58.6922197482, 59.2815027678, 59.765030527
};

consteval array<float, MN> to_prob(const array<float, MN>& arr) {
    array<float, MN> result;
    for (int i = 0; i < MN; ++i) result[i] = arr[i] / 100 * 0.9;
    return result;
}
constexpr array<float, MN> P_GOOD = to_prob(EXPECTED_P);

constexpr int MID = MN / 2;
constexpr int K_OFFSET = 30;
constexpr float P_K_GOOD[MID - K_OFFSET + 1][MN] = {
    {0.00473048, 0.0122968, 0.020452, 0.0285441, 0.0364943, 0.044185, 0.0520195, 0.0594719, 0.0668927, 0.0743679, 0.0813891, 0.0884454, 0.0952861, 0.102129, 0.10888, 0.115664, 0.122286, 0.128477, 0.134858, 0.140964, 0.147262, 0.153433, 0.159525, 0.165511, 0.171494, 0.177432, 0.183279, 0.188954, 0.19467, 0.200293, 0.205731, 0.211364, 0.217018, 0.222387, 0.227729, 0.233013, 0.238324, 0.243706, 0.248857, 0.254128, 0.2591, 0.264246, 0.269155, 0.274261, 0.27921, 0.2842, 0.28896, 0.293745, 0.298712, 0.303509, 0.308314, 0.3131, 0.317857, 0.322468, 0.327335, 0.332129, 0.336754, 0.341702, 0.346366, 0.3512, 0.355858, 0.36061, 0.365421, 0.370139, 0.37491, 0.379604, 0.384173, 0.388765, 0.393508, 0.398154, 0.402732, 0.407371, 0.412028, 0.416676, 0.421438, 0.42619, 0.430938, 0.435716, 0.440402, 0.445078, 0.449942, 0.454655, 0.459417, 0.464097, 0.468783, 0.47357, 0.47808, 0.482752, 0.487469, 0.49231, 0.497021, 0.501811, 0.506527, 0.511337, 0.516011, 0.520813, 0.525646, 0.530378, 0.534868, 0.538419},
    {0.00447467, 0.0117111, 0.0196262, 0.0274268, 0.0351148, 0.0427312, 0.0500831, 0.0573771, 0.0647952, 0.071923, 0.0790513, 0.0858162, 0.0926156, 0.0993858, 0.105984, 0.112645, 0.119134, 0.125643, 0.131917, 0.138176, 0.144381, 0.150542, 0.156537, 0.162619, 0.168479, 0.174305, 0.180209, 0.185956, 0.191649, 0.197361, 0.202983, 0.208556, 0.214101, 0.2195, 0.224938, 0.23028, 0.235587, 0.240806, 0.245978, 0.25116, 0.256273, 0.261359, 0.26652, 0.271545, 0.276539, 0.281587, 0.286516, 0.291397, 0.296259, 0.301079, 0.305771, 0.31055, 0.315352, 0.320144, 0.324842, 0.329623, 0.334495, 0.339235, 0.343941, 0.348679, 0.35353, 0.35831, 0.363116, 0.367947, 0.372704, 0.37743, 0.382206, 0.38698, 0.391748, 0.396554, 0.401478, 0.406327, 0.411102, 0.415847, 0.420599, 0.425326, 0.430113, 0.434795, 0.43951, 0.44431, 0.449037, 0.453835, 0.458597, 0.46337, 0.468133, 0.472909, 0.477717, 0.482457, 0.487162, 0.491945, 0.496783, 0.501524, 0.50624, 0.511007, 0.515787, 0.520548, 0.525419, 0.530228, 0.534849, 0.538455},
    {0.00422578, 0.0111949, 0.0187947, 0.0264209, 0.0338435, 0.0411801, 0.048409, 0.0556075, 0.0626636, 0.069677, 0.0766188, 0.0834628, 0.0902197, 0.0968942, 0.103527, 0.110049, 0.116492, 0.122827, 0.129136, 0.13534, 0.14155, 0.147673, 0.153731, 0.159705, 0.165667, 0.171523, 0.177338, 0.183085, 0.188804, 0.194493, 0.200094, 0.20566, 0.211179, 0.216645, 0.222129, 0.227477, 0.232856, 0.23815, 0.243446, 0.248641, 0.253823, 0.258978, 0.264098, 0.269156, 0.274195, 0.27916, 0.284136, 0.289036, 0.293926, 0.298818, 0.303619, 0.308369, 0.313201, 0.318012, 0.32282, 0.327618, 0.332433, 0.337283, 0.342064, 0.346885, 0.351688, 0.356502, 0.36128, 0.366061, 0.370891, 0.375699, 0.380512, 0.385329, 0.390156, 0.394968, 0.399794, 0.404607, 0.409433, 0.414287, 0.41908, 0.423921, 0.428768, 0.43361, 0.438401, 0.443279, 0.448102, 0.452881, 0.457688, 0.462523, 0.467352, 0.472184, 0.476993, 0.481819, 0.486655, 0.491488, 0.496293, 0.501126, 0.50596, 0.510809, 0.515636, 0.52043, 0.525278, 0.530154, 0.534802, 0.538373},
    {0.00398245, 0.0106986, 0.0180807, 0.0254528, 0.0326986, 0.0398709, 0.0469443, 0.053983, 0.0609051, 0.0677711, 0.0745717, 0.0812911, 0.0879269, 0.0944764, 0.100967, 0.107391, 0.113741, 0.120045, 0.126283, 0.13244, 0.138587, 0.144678, 0.150699, 0.156681, 0.162573, 0.168432, 0.174234, 0.180022, 0.185753, 0.191398, 0.197033, 0.202591, 0.208101, 0.213591, 0.21904, 0.224432, 0.229794, 0.235123, 0.240404, 0.245659, 0.250883, 0.256062, 0.26121, 0.266292, 0.271359, 0.276391, 0.281382, 0.286338, 0.291267, 0.296185, 0.301052, 0.305923, 0.310772, 0.315639, 0.320524, 0.325414, 0.330289, 0.33516, 0.340052, 0.344911, 0.349758, 0.354641, 0.359501, 0.364373, 0.36924, 0.374112, 0.378996, 0.383888, 0.38875, 0.393629, 0.398483, 0.403363, 0.408218, 0.413102, 0.417951, 0.42282, 0.427689, 0.432553, 0.437418, 0.442279, 0.44715, 0.451998, 0.456897, 0.461736, 0.46662, 0.471513, 0.476404, 0.481259, 0.486111, 0.490972, 0.495876, 0.500736, 0.505603, 0.510477, 0.515324, 0.520187, 0.525099, 0.529994, 0.534671, 0.538335},
    {0.00372267, 0.0101684, 0.0173276, 0.0244722, 0.0315442, 0.0385123, 0.0454355, 0.0522949, 0.0590742, 0.0657924, 0.0724503, 0.0790461, 0.0855799, 0.0920525, 0.0984578, 0.104824, 0.111117, 0.11735, 0.123532, 0.129677, 0.13577, 0.141798, 0.147789, 0.153716, 0.159595, 0.165435, 0.171222, 0.176982, 0.182675, 0.188336, 0.19395, 0.199532, 0.205068, 0.210572, 0.216024, 0.22145, 0.226818, 0.232157, 0.237468, 0.242748, 0.247984, 0.253193, 0.258365, 0.263507, 0.268608, 0.273675, 0.278713, 0.28372, 0.288706, 0.293648, 0.298557, 0.303484, 0.308404, 0.313324, 0.318248, 0.323174, 0.3281, 0.333018, 0.33795, 0.342875, 0.347792, 0.352712, 0.357639, 0.362546, 0.367452, 0.372374, 0.377296, 0.382218, 0.387144, 0.392065, 0.396985, 0.401908, 0.406835, 0.411734, 0.416642, 0.421573, 0.426474, 0.431391, 0.436312, 0.441232, 0.446148, 0.451057, 0.455973, 0.460895, 0.465809, 0.470727, 0.475651, 0.480569, 0.4855, 0.490423, 0.495328, 0.500252, 0.505152, 0.510071, 0.514995, 0.519928, 0.524856, 0.529798, 0.534548, 0.538295},
    {0.00350968, 0.00970094, 0.0166289, 0.0235642, 0.0304306, 0.0372273, 0.0439724, 0.0506586, 0.0573106, 0.0638893, 0.0704251, 0.0768816, 0.0833108, 0.0896883, 0.0959928, 0.102258, 0.10848, 0.11464, 0.120763, 0.126835, 0.132857, 0.138841, 0.144779, 0.150678, 0.156531, 0.16234, 0.168103, 0.173829, 0.179513, 0.185167, 0.190782, 0.196359, 0.201897, 0.207406, 0.212877, 0.218303, 0.223708, 0.229072, 0.234417, 0.239708, 0.244978, 0.250213, 0.255406, 0.260587, 0.265726, 0.270834, 0.275909, 0.280968, 0.285994, 0.291002, 0.295972, 0.300944, 0.305906, 0.31088, 0.315847, 0.320817, 0.32579, 0.330758, 0.335726, 0.340698, 0.345676, 0.350642, 0.355617, 0.360583, 0.365554, 0.370519, 0.37549, 0.380457, 0.385432, 0.3904, 0.395373, 0.400346, 0.405316, 0.410284, 0.415259, 0.420233, 0.425216, 0.430183, 0.435156, 0.440119, 0.445081, 0.450058, 0.455035, 0.460002, 0.464972, 0.469949, 0.474919, 0.47988, 0.48485, 0.489821, 0.494788, 0.499758, 0.504726, 0.509695, 0.514667, 0.519643, 0.524626, 0.529625, 0.53443, 0.538251},
    {0.00330662, 0.00924116, 0.0159559, 0.0226895, 0.0293706, 0.0359909, 0.0425691, 0.0490896, 0.0555754, 0.0620083, 0.0683974, 0.074741, 0.0810361, 0.0872989, 0.0935177, 0.099692, 0.105821, 0.111918, 0.11797, 0.123978, 0.129952, 0.135887, 0.141779, 0.147637, 0.153457, 0.159245, 0.164986, 0.170702, 0.176377, 0.182021, 0.187628, 0.193204, 0.198747, 0.204254, 0.209732, 0.215182, 0.220601, 0.225982, 0.231333, 0.236656, 0.241949, 0.247222, 0.252458, 0.257668, 0.26285, 0.268009, 0.273133, 0.278236, 0.283316, 0.288366, 0.293383, 0.298403, 0.303426, 0.308449, 0.313474, 0.318496, 0.323519, 0.328546, 0.333565, 0.338593, 0.343613, 0.348638, 0.353659, 0.358681, 0.363709, 0.368727, 0.373747, 0.378766, 0.383786, 0.388809, 0.393829, 0.398856, 0.403879, 0.408901, 0.413921, 0.418945, 0.423966, 0.428987, 0.434009, 0.439038, 0.444059, 0.449082, 0.454105, 0.459127, 0.464153, 0.469171, 0.474194, 0.479215, 0.484239, 0.489263, 0.494279, 0.499305, 0.504325, 0.509342, 0.514362, 0.519391, 0.524426, 0.529479, 0.534339, 0.538211},
    {0.00310789, 0.00880693, 0.0153004, 0.0218403, 0.0283319, 0.0347764, 0.0411889, 0.0475615, 0.0538975, 0.060191, 0.0664485, 0.0726699, 0.0788563, 0.085005, 0.0911193, 0.0971996, 0.103245, 0.109251, 0.11523, 0.121176, 0.127087, 0.132963, 0.138805, 0.144619, 0.150395, 0.156144, 0.161864, 0.167551, 0.173212, 0.178838, 0.184438, 0.190008, 0.195546, 0.201058, 0.206544, 0.212003, 0.21743, 0.222834, 0.228206, 0.233552, 0.23887, 0.244166, 0.249438, 0.254683, 0.259902, 0.265098, 0.27027, 0.275416, 0.280537, 0.285637, 0.290707, 0.295784, 0.300862, 0.305936, 0.311015, 0.316091, 0.321167, 0.326238, 0.331313, 0.336387, 0.341467, 0.346541, 0.351616, 0.356691, 0.361767, 0.366842, 0.371919, 0.376994, 0.382072, 0.387152, 0.392225, 0.397302, 0.402379, 0.407454, 0.412529, 0.417607, 0.422682, 0.427757, 0.432831, 0.437909, 0.442985, 0.448058, 0.453128, 0.458204, 0.463278, 0.468357, 0.47343, 0.478508, 0.483583, 0.488659, 0.493736, 0.498814, 0.503891, 0.508966, 0.514042, 0.519118, 0.524207, 0.529312, 0.534231, 0.538169},
    {0.00292341, 0.00837721, 0.0146657, 0.0210225, 0.0273318, 0.0336055, 0.039849, 0.046064, 0.0522494, 0.0584044, 0.0645312, 0.07063, 0.0766966, 0.0827355, 0.0887492, 0.0947311, 0.100687, 0.106615, 0.112512, 0.118383, 0.124229, 0.130044, 0.135836, 0.141599, 0.147334, 0.153047, 0.158733, 0.164394, 0.170027, 0.175638, 0.181222, 0.186783, 0.192319, 0.197828, 0.203314, 0.208776, 0.214217, 0.219636, 0.225027, 0.230395, 0.235743, 0.241068, 0.246371, 0.251652, 0.256907, 0.262145, 0.267358, 0.272546, 0.277721, 0.282872, 0.287997, 0.293127, 0.298256, 0.303387, 0.308518, 0.313648, 0.318779, 0.323909, 0.329039, 0.33417, 0.3393, 0.344428, 0.349559, 0.354689, 0.359818, 0.364948, 0.370076, 0.375205, 0.380334, 0.385465, 0.390595, 0.395727, 0.400856, 0.405984, 0.411114, 0.416246, 0.421377, 0.426508, 0.431637, 0.436768, 0.441899, 0.447027, 0.452156, 0.457287, 0.462415, 0.467547, 0.472678, 0.477807, 0.482938, 0.488067, 0.493197, 0.498326, 0.503456, 0.508587, 0.513716, 0.518847, 0.523991, 0.52915, 0.534127, 0.538127},
    {0.00274707, 0.00797497, 0.0140622, 0.0202346, 0.0263673, 0.032474, 0.0385566, 0.0446188, 0.050659, 0.0566751, 0.0626692, 0.0686392, 0.0745893, 0.0805197, 0.0864234, 0.0923078, 0.0981687, 0.104009, 0.109826, 0.115622, 0.121399, 0.127153, 0.132886, 0.138598, 0.144291, 0.149962, 0.155614, 0.161241, 0.16685, 0.172438, 0.178005, 0.183551, 0.189078, 0.194584, 0.200072, 0.20554, 0.210987, 0.216416, 0.221825, 0.227215, 0.232586, 0.237936, 0.243268, 0.248581, 0.253877, 0.259153, 0.264412, 0.269653, 0.274873, 0.280077, 0.285259, 0.290442, 0.295627, 0.300813, 0.305996, 0.31118, 0.316366, 0.321552, 0.326737, 0.331921, 0.337105, 0.34229, 0.347476, 0.352663, 0.357847, 0.36303, 0.368218, 0.373402, 0.378586, 0.383769, 0.388953, 0.394139, 0.399325, 0.404508, 0.409693, 0.414878, 0.420064, 0.425247, 0.430432, 0.435617, 0.440801, 0.445986, 0.45117, 0.456357, 0.461542, 0.466727, 0.47191, 0.477096, 0.482281, 0.487466, 0.49265, 0.497834, 0.50302, 0.508205, 0.51339, 0.518575, 0.523772, 0.528987, 0.534022, 0.538084},
    {0.00258096, 0.00759012, 0.0134837, 0.0194778, 0.0254418, 0.0313824, 0.0373071, 0.0432171, 0.0491108, 0.0549875, 0.0608501, 0.0666968, 0.0725269, 0.0783409, 0.0841407, 0.0899234, 0.0956902, 0.101442, 0.107178, 0.112896, 0.118598, 0.124286, 0.129958, 0.135614, 0.141254, 0.14688, 0.152487, 0.15808, 0.163656, 0.169217, 0.174763, 0.180295, 0.18581, 0.191309, 0.196792, 0.202259, 0.207711, 0.213149, 0.218572, 0.223978, 0.22937, 0.234744, 0.240105, 0.24545, 0.250781, 0.256097, 0.261397, 0.266683, 0.271954, 0.277209, 0.282447, 0.287687, 0.292927, 0.298169, 0.303409, 0.308651, 0.313891, 0.319133, 0.324374, 0.329615, 0.334855, 0.340096, 0.345338, 0.35058, 0.355821, 0.361061, 0.366302, 0.371544, 0.376785, 0.382025, 0.387268, 0.392509, 0.39775, 0.40299, 0.408231, 0.413472, 0.418713, 0.423954, 0.429195, 0.434436, 0.439678, 0.44492, 0.450161, 0.4554, 0.460642, 0.465884, 0.471125, 0.476366, 0.481607, 0.486849, 0.492091, 0.497331, 0.502572, 0.507814, 0.513055, 0.518295, 0.523547, 0.528817, 0.533913, 0.53804},
    {0.00242313, 0.00721872, 0.0129228, 0.0187467, 0.0245427, 0.0303213, 0.0360902, 0.0418508, 0.0476035, 0.0533429, 0.059074, 0.0647957, 0.0705071, 0.0762073, 0.0818974, 0.0875773, 0.0932474, 0.098907, 0.104557, 0.110196, 0.115824, 0.121442, 0.127049, 0.132646, 0.138232, 0.143808, 0.149372, 0.154926, 0.160468, 0.166002, 0.171523, 0.177033, 0.182532, 0.18802, 0.193497, 0.198963, 0.204419, 0.209863, 0.215295, 0.220715, 0.226125, 0.231524, 0.236912, 0.242289, 0.247655, 0.253008, 0.258351, 0.263682, 0.269003, 0.274313, 0.279609, 0.284907, 0.290205, 0.295502, 0.300802, 0.306098, 0.311396, 0.316695, 0.321992, 0.327291, 0.332588, 0.337886, 0.343184, 0.348481, 0.353779, 0.359075, 0.364374, 0.369672, 0.374969, 0.380267, 0.385565, 0.390863, 0.396161, 0.401458, 0.406755, 0.412052, 0.41735, 0.422648, 0.427946, 0.433243, 0.43854, 0.443839, 0.449136, 0.454435, 0.459734, 0.465031, 0.470329, 0.475626, 0.480925, 0.486222, 0.491519, 0.496817, 0.502117, 0.507414, 0.512712, 0.51801, 0.523319, 0.528646, 0.533803, 0.537996},
    {0.00227445, 0.00686346, 0.0123832, 0.0180397, 0.0236753, 0.0292981, 0.0349166, 0.0405304, 0.04614, 0.0517461, 0.0573461, 0.062942, 0.0685336, 0.0741192, 0.0797, 0.085276, 0.0908471, 0.0964126, 0.101973, 0.107528, 0.113079, 0.118623, 0.124161, 0.129695, 0.135223, 0.140745, 0.146261, 0.151771, 0.157275, 0.162773, 0.168264, 0.173749, 0.179229, 0.184702, 0.190168, 0.195628, 0.201082, 0.206529, 0.211969, 0.217403, 0.222829, 0.22825, 0.233663, 0.239068, 0.244468, 0.249859, 0.255243, 0.260621, 0.265991, 0.271354, 0.276709, 0.282065, 0.287421, 0.292777, 0.298133, 0.303489, 0.308844, 0.3142, 0.319556, 0.32491, 0.330266, 0.335622, 0.340978, 0.346335, 0.35169, 0.357047, 0.362403, 0.367758, 0.373114, 0.378471, 0.383827, 0.389182, 0.394537, 0.399894, 0.405249, 0.410605, 0.41596, 0.421316, 0.426672, 0.432028, 0.437383, 0.442738, 0.448094, 0.453449, 0.458805, 0.464161, 0.469517, 0.474873, 0.480229, 0.485585, 0.49094, 0.496296, 0.501651, 0.507007, 0.512363, 0.517718, 0.523086, 0.52847, 0.53369, 0.53795},
    {0.00213339, 0.00652264, 0.0118643, 0.0173591, 0.0228367, 0.0283056, 0.0337744, 0.039244, 0.0447142, 0.050184, 0.055656, 0.061127, 0.0665983, 0.0720683, 0.0775376, 0.0830087, 0.0884777, 0.0939481, 0.0994175, 0.104887, 0.110355, 0.115822, 0.121289, 0.126756, 0.132222, 0.137686, 0.14315, 0.148612, 0.154073, 0.159532, 0.16499, 0.170448, 0.175904, 0.181358, 0.18681, 0.192261, 0.19771, 0.203156, 0.208601, 0.214044, 0.219484, 0.224923, 0.230359, 0.235793, 0.241225, 0.246654, 0.252082, 0.257505, 0.262926, 0.268343, 0.273758, 0.279173, 0.284588, 0.290002, 0.295418, 0.300833, 0.306248, 0.311663, 0.317078, 0.322493, 0.327907, 0.333322, 0.338735, 0.34415, 0.349565, 0.35498, 0.360396, 0.36581, 0.371225, 0.37664, 0.382055, 0.38747, 0.392885, 0.3983, 0.403715, 0.409129, 0.414544, 0.419958, 0.425372, 0.430787, 0.436202, 0.441618, 0.447033, 0.452448, 0.457863, 0.463277, 0.468692, 0.474106, 0.479521, 0.484935, 0.49035, 0.495765, 0.501181, 0.506595, 0.51201, 0.517424, 0.52285, 0.528293, 0.533575, 0.537903},
    {0.0019973, 0.00619342, 0.0113595, 0.0166979, 0.0220231, 0.0273426, 0.032665, 0.0379923, 0.0433252, 0.0486623, 0.0540043, 0.0593505, 0.0647007, 0.070056, 0.0754157, 0.0807787, 0.0861458, 0.0915185, 0.0968943, 0.102274, 0.107658, 0.113047, 0.118438, 0.123834, 0.129235, 0.134639, 0.140046, 0.145457, 0.150872, 0.156289, 0.161711, 0.167136, 0.172564, 0.177997, 0.183431, 0.188868, 0.194308, 0.199752, 0.2052, 0.21065, 0.216102, 0.221557, 0.227014, 0.232474, 0.237936, 0.2434, 0.248867, 0.254335, 0.259806, 0.265279, 0.270754, 0.276229, 0.281705, 0.287179, 0.292654, 0.298129, 0.303604, 0.309079, 0.314554, 0.320029, 0.325504, 0.330979, 0.336453, 0.341928, 0.347404, 0.352879, 0.358355, 0.363829, 0.369303, 0.374778, 0.380253, 0.385728, 0.391204, 0.396679, 0.402154, 0.407628, 0.413103, 0.418578, 0.424054, 0.429528, 0.435003, 0.440478, 0.445954, 0.451429, 0.456903, 0.462379, 0.467853, 0.473328, 0.478802, 0.484276, 0.489751, 0.495225, 0.5007, 0.506175, 0.511649, 0.517124, 0.522608, 0.528112, 0.533457, 0.537854},
    {0.00187091, 0.00588015, 0.010876, 0.0160607, 0.0212385, 0.0264102, 0.0315898, 0.0367787, 0.0419763, 0.0471818, 0.0523964, 0.0576188, 0.0628502, 0.0680891, 0.0733374, 0.0785941, 0.0838586, 0.0891301, 0.0944112, 0.0997005, 0.104998, 0.110303, 0.115619, 0.120942, 0.126272, 0.131611, 0.136957, 0.142313, 0.147677, 0.153048, 0.158428, 0.163818, 0.169215, 0.17462, 0.180033, 0.185454, 0.190883, 0.196319, 0.201764, 0.207216, 0.212677, 0.218145, 0.22362, 0.229104, 0.234595, 0.240094, 0.2456, 0.251114, 0.256634, 0.262163, 0.267701, 0.273237, 0.278773, 0.284309, 0.289845, 0.295382, 0.300918, 0.306453, 0.311989, 0.317525, 0.323062, 0.328597, 0.334133, 0.339668, 0.345204, 0.35074, 0.356277, 0.361813, 0.367349, 0.372884, 0.37842, 0.383957, 0.389492, 0.395028, 0.400564, 0.406101, 0.411637, 0.417173, 0.42271, 0.428245, 0.433781, 0.439317, 0.444853, 0.450389, 0.455925, 0.461461, 0.466997, 0.472532, 0.478068, 0.483604, 0.48914, 0.494676, 0.500211, 0.505748, 0.511284, 0.516819, 0.522365, 0.527928, 0.533338, 0.537806},
     {0.00174873, 0.00557494, 0.010405, 0.015442, 0.0204737, 0.025502, 0.0305411, 0.0355931, 0.0406584, 0.045734, 0.050822, 0.055922, 0.0610332, 0.066157, 0.0712931, 0.0764396, 0.0815991, 0.08677, 0.0919546, 0.0971506, 0.102359, 0.10758, 0.112814, 0.11806, 0.123318, 0.128588, 0.133873, 0.139169, 0.144478, 0.1498, 0.155135, 0.160482, 0.165842, 0.171217, 0.176604, 0.182004, 0.187415, 0.192842, 0.19828, 0.203731, 0.209197, 0.214676, 0.220167, 0.225672, 0.231191, 0.236723, 0.242268, 0.247826, 0.253397, 0.258983, 0.264583, 0.270181, 0.275779, 0.281377, 0.286976, 0.292574, 0.298172, 0.303771, 0.309369, 0.314967, 0.320565, 0.326162, 0.331761, 0.337359, 0.342957, 0.348555, 0.354153, 0.359752, 0.36535, 0.370949, 0.376548, 0.382146, 0.387745, 0.393344, 0.398941, 0.40454, 0.410137, 0.415736, 0.421334, 0.426932, 0.43253, 0.438129, 0.443727, 0.449324, 0.454923, 0.460522, 0.46612, 0.471718, 0.477317, 0.482915, 0.488513, 0.494112, 0.499711, 0.505309, 0.510908, 0.516507, 0.522113, 0.527738, 0.533216, 0.537755},
     {0.00163318, 0.00528081, 0.00994925, 0.0148411, 0.0197339, 0.0246233, 0.0295261, 0.0344454, 0.0393778, 0.044325, 0.0492887, 0.0542644, 0.0592577, 0.0642658, 0.0692884, 0.0743266, 0.0793798, 0.0844501, 0.0895362, 0.0946377, 0.0997558, 0.104889, 0.11004, 0.115206, 0.120391, 0.12559, 0.130807, 0.13604, 0.141292, 0.14656, 0.151846, 0.157148, 0.162469, 0.167806, 0.173163, 0.178538, 0.183931, 0.189342, 0.194771, 0.20022, 0.205687, 0.211174, 0.216679, 0.222202, 0.227745, 0.233307, 0.238889, 0.24449, 0.250112, 0.255753, 0.261419, 0.267081, 0.272742, 0.278402, 0.284064, 0.289726, 0.295387, 0.301048, 0.306709, 0.31237, 0.318031, 0.323692, 0.329355, 0.335016, 0.340681, 0.346343, 0.352004, 0.357666, 0.363328, 0.368989, 0.374652, 0.380313, 0.385973, 0.391635, 0.397295, 0.402958, 0.408619, 0.41428, 0.419939, 0.4256, 0.431261, 0.436923, 0.442585, 0.448247, 0.45391, 0.459572, 0.465235, 0.470897, 0.476559, 0.482221, 0.487881, 0.493543, 0.499205, 0.504867, 0.51053, 0.51619, 0.521862, 0.527548, 0.533092, 0.537704},
     {0.00152327, 0.00500128, 0.00951098, 0.0142613, 0.019016, 0.0237672, 0.0285353, 0.0333215, 0.0381244, 0.0429443, 0.0477821, 0.0526381, 0.0575123, 0.062405, 0.067316, 0.0722454, 0.0771943, 0.0821614, 0.0871471, 0.0921512, 0.0971764, 0.10222, 0.107282, 0.112366, 0.117471, 0.122596, 0.127741, 0.13291, 0.138098, 0.14331, 0.148543, 0.153799, 0.159073, 0.164372, 0.169694, 0.175038, 0.180408, 0.185801, 0.191218, 0.196656, 0.202122, 0.207613, 0.213127, 0.218667, 0.224232, 0.229822, 0.235441, 0.241085, 0.246757, 0.252458, 0.258187, 0.263913, 0.269639, 0.275362, 0.28109, 0.286816, 0.29254, 0.298265, 0.303992, 0.309718, 0.315443, 0.32117, 0.326895, 0.332622, 0.338349, 0.344076, 0.349802, 0.35553, 0.361256, 0.366981, 0.372706, 0.378433, 0.384156, 0.389884, 0.395609, 0.401334, 0.40706, 0.412788, 0.418515, 0.42424, 0.429968, 0.435693, 0.441421, 0.447147, 0.452875, 0.458602, 0.464327, 0.470054, 0.475781, 0.481507, 0.487233, 0.49296, 0.498686, 0.504411, 0.510137, 0.515864, 0.5216, 0.527352, 0.532966, 0.537651},
     {0.00141722, 0.00472796, 0.00907771, 0.0136971, 0.0183185, 0.0229342, 0.0275729, 0.0322289, 0.0369045, 0.0416023, 0.0463185, 0.0510506, 0.0558085, 0.0605891, 0.0653878, 0.0702059, 0.0750419, 0.0799076, 0.0847912, 0.0897028, 0.0946323, 0.099586, 0.104565, 0.109562, 0.114589, 0.119639, 0.124707, 0.129806, 0.134926, 0.140073, 0.145247, 0.150448, 0.155682, 0.160938, 0.166225, 0.171532, 0.17687, 0.182239, 0.187635, 0.193063, 0.198524, 0.204015, 0.209533, 0.21508, 0.220663, 0.226283, 0.231934, 0.237621, 0.243347, 0.249102, 0.254904, 0.2607, 0.26649, 0.272279, 0.27807, 0.283866, 0.289656, 0.295445, 0.301238, 0.307031, 0.312823, 0.318618, 0.324417, 0.330208, 0.335998, 0.34179, 0.347581, 0.353379, 0.359172, 0.364961, 0.370758, 0.376545, 0.382336, 0.388128, 0.393919, 0.399714, 0.405504, 0.411294, 0.417086, 0.422881, 0.42867, 0.434458, 0.440252, 0.446042, 0.451835, 0.457631, 0.463422, 0.469214, 0.475005, 0.480796, 0.486588, 0.492377, 0.498166, 0.503958, 0.509751, 0.51554, 0.521337, 0.527155, 0.532834, 0.537599},
     {0.00131966, 0.00446131, 0.00865846, 0.0131335, 0.0176272, 0.0221121, 0.0266254, 0.0311563, 0.0357045, 0.0402692, 0.0448642, 0.049489, 0.0541285, 0.0587866, 0.0634824, 0.0681875, 0.0729224, 0.0776786, 0.0824565, 0.0872716, 0.0921015, 0.0969641, 0.101849, 0.106771, 0.111701, 0.116672, 0.12167, 0.126704, 0.131757, 0.136837, 0.141942, 0.147095, 0.152272, 0.157482, 0.162728, 0.167995, 0.173311, 0.178646, 0.18401, 0.189436, 0.194889, 0.200372, 0.205896, 0.21146, 0.21707, 0.222705, 0.228381, 0.234108, 0.239883, 0.2457, 0.251568, 0.257419, 0.263275, 0.269143, 0.274998, 0.28086, 0.28671, 0.292571, 0.298431, 0.304274, 0.310132, 0.315989, 0.321835, 0.327705, 0.333557, 0.339411, 0.345266, 0.351123, 0.356992, 0.362848, 0.368706, 0.37458, 0.380436, 0.38631, 0.392172, 0.398026, 0.403864, 0.409721, 0.415579, 0.421435, 0.42729, 0.43315, 0.439013, 0.444861, 0.45073, 0.456599, 0.462463, 0.468333, 0.474207, 0.480055, 0.485915, 0.491771, 0.497639, 0.503487, 0.509348, 0.515196, 0.521062, 0.526956, 0.532712, 0.537548}
};

constexpr float PASS_PRELIM_PASS_STANDARD_GOOD = 0.8 * 0.9;
constexpr float FAIL_PRELIM_GOOD = 0.2;
constexpr float PASS_PRELIM_FAIL_STANDARD_GOOD = 0.8 * 0.1;
static_assert(abs(1 - (PASS_PRELIM_PASS_STANDARD_GOOD + FAIL_PRELIM_GOOD + PASS_PRELIM_FAIL_STANDARD_GOOD)) < EPS);

constexpr float PASS_PRELIM_PASS_STANDARD_BAD = 0.2 * 0.1;
constexpr float FAIL_PRELIM_BAD = 0.8;
constexpr float PASS_PRELIM_FAIL_STANDARD_BAD = 0.2 * 0.9;
static_assert(abs(1 - (PASS_PRELIM_PASS_STANDARD_BAD + FAIL_PRELIM_BAD + PASS_PRELIM_FAIL_STANDARD_BAD)) < EPS);

constexpr float PASS_STANDARD_GOOD = 0.9;
constexpr float FAIL_STANDARD_GOOD = 1 - PASS_STANDARD_GOOD;

constexpr float PASS_STANDARD_BAD = 0.1;
constexpr float FAIL_STANDARD_BAD = 1 - PASS_STANDARD_BAD;

consteval array<float, MN> calculate_p(const float p_if_good, const float p_if_bad) {
    array<float, MN> arr;
    for (int n = 0; n < MN; ++n) arr[n] = P_GOOD[n] * p_if_good + (1 - P_GOOD[n]) * p_if_bad;
    return arr;
}
constexpr array<float, MN> P_FAIL_PRELIM = calculate_p(FAIL_PRELIM_GOOD, FAIL_PRELIM_BAD);
constexpr array<float, MN> P_PASS_PRELIM_FAIL_STANDARD = calculate_p(PASS_PRELIM_FAIL_STANDARD_GOOD, PASS_PRELIM_FAIL_STANDARD_BAD);
constexpr array<float, MN> P_PASS_PRELIM_PASS_STANDARD = calculate_p(PASS_PRELIM_PASS_STANDARD_GOOD, PASS_PRELIM_PASS_STANDARD_BAD);

constexpr array<float, MN> P_FAIL_STANDARD = calculate_p(FAIL_STANDARD_GOOD, FAIL_STANDARD_BAD);
constexpr array<float, MN> P_PASS_STANDARD = calculate_p(PASS_STANDARD_GOOD, PASS_STANDARD_BAD);

consteval array<float, MN> calculate_p_is_good(const float p_if_good, const float p_if_bad) {
    array<float, MN> arr;
    for (int n = 0; n < MN; ++n) arr[n] = P_GOOD[n] * p_if_good / (P_GOOD[n] * p_if_good + (1 - P_GOOD[n]) * p_if_bad);
    return arr;
}
constexpr array<float, MN> P_GOOD_PASS_PRELIM_PASS_STANDARD = calculate_p_is_good(PASS_PRELIM_PASS_STANDARD_GOOD, PASS_PRELIM_PASS_STANDARD_BAD);
constexpr array<float, MN> P_GOOD_PASS_STANDARD = calculate_p_is_good(PASS_STANDARD_GOOD, PASS_STANDARD_BAD);


array<float, MN> p_good = P_GOOD;

array<float, MN> p_fail_prelim = P_FAIL_PRELIM;
array<float, MN> p_pass_prelim_fail_standard = P_PASS_PRELIM_FAIL_STANDARD;
array<float, MN> p_pass_prelim_pass_standard = P_PASS_PRELIM_PASS_STANDARD;

array<float, MN> p_fail_standard = P_FAIL_STANDARD;
array<float, MN> p_pass_standard = P_PASS_STANDARD;

array<float, MN> p_good_pass_prelim_pass_standard = P_GOOD_PASS_PRELIM_PASS_STANDARD;
array<float, MN> p_good_pass_standard = P_GOOD_PASS_STANDARD;

constexpr int SKIPS = 1;
constexpr int PASS = 59;
constexpr int N_OFFSET = PASS;
static_assert(N_OFFSET >= PASS && PASS >= SKIPS);


constexpr int MAX_TIME = 900;
constexpr int MAX_HIRES = 22;
constexpr int MN_RANGE = 59;
constexpr int MX_RANGE = 9;
float cache[(MN - N_OFFSET + 1) >> 1][MAX_TIME + 1][MAX_HIRES + 1][MN_RANGE + 1][MX_RANGE + 1]; // = expected score, assuming all candidates are good
int N;

float expectimax(const int n, const int time_spent, const int hires, const int mn, const int inv_mx, int& action) {
    if (hires + (N - n) < 5 || time_spent > MAX_TIME || hires > MAX_HIRES) return 0;
    if (n == N) {
        // inv_mx = N - mx - 1
        return SCORE_NUMER[hires] / ((time_spent + 2) * (mn + inv_mx + 1) + 2);
    }

    if (action != -1 && n >= N_OFFSET && ((n - N_OFFSET) & 1) && cache[(n - N_OFFSET) >> 1][time_spent][hires][mn][inv_mx] != 0) {
        return cache[(n - N_OFFSET) >> 1][time_spent][hires][mn][inv_mx];
    }
    action = 0;

    const int new_mn = min(mn, n);
    const int new_mx = min(inv_mx, N - n - 1);
    const float options[4] = {
        // reject immediately
        expectimax(n + 1, time_spent, hires, mn, inv_mx, action),

        // prelim and standard interview
        p_fail_prelim[n]               * expectimax(n + 1, time_spent + 4,  hires,     mn,     inv_mx, action) +
        p_pass_prelim_fail_standard[n] * expectimax(n + 1, time_spent + 16, hires,     mn,     inv_mx, action) +
        p_pass_prelim_pass_standard[n] * expectimax(n + 1, time_spent + 16, hires + 1, new_mn, new_mx, action) * p_good_pass_prelim_pass_standard[n],

        // standard interview only
        p_fail_standard[n] * expectimax(n + 1, time_spent + 12, hires,     mn,     inv_mx, action) +
        p_pass_standard[n] * expectimax(n + 1, time_spent + 12, hires + 1, new_mn, new_mx, action) * p_good_pass_standard[n],

        // accept immediately
        expectimax(n + 1, time_spent + 1, hires + 1, new_mn, new_mx, action) * P_GOOD[n]
    };

    // prioritize actions 1 and 2 first
    if (options[1] >= options[0] && options[1] >= options[2] && options[1] >= options[3]) {
        action = 1;
    } else if (options[2] >= options[0] && options[2] >= options[3]) {
        action = 2;
    } else if (options[0] >= options[3]) {
        action = 0;
    } else {
        action = 3;
    }

    if (n >= N_OFFSET && ((n - N_OFFSET) & 1)) cache[(n - N_OFFSET) >> 1][time_spent][hires][mn][inv_mx] = options[action];
    return options[action];
}

float strategy(const unique_ptr<Interactor>& interactor) {
    int action = -1;
    //for (int i = PASS; i < PASS + 4; ++i) expectimax(i, 0, 0, i, MX_RANGE, action);  // for testing time

    string s;
    for (int i = 0; i < N; ++i) {
        if (i == 50) {
            // figure out how to use k later
            const int k = interactor->get_k();
            const int shifted_k = max(0, k - K_OFFSET);
            for (int n = 0; n < N; ++n) {
                p_good[n] = P_K_GOOD[shifted_k][n];

                p_fail_prelim[n] = p_good[n] * FAIL_PRELIM_GOOD + (1 - p_good[n]) * FAIL_PRELIM_BAD;
                p_pass_prelim_fail_standard[n] = p_good[n] * PASS_PRELIM_FAIL_STANDARD_GOOD + (1 - p_good[n]) * PASS_PRELIM_FAIL_STANDARD_BAD;
                p_pass_prelim_pass_standard[n] = p_good[n] * PASS_PRELIM_PASS_STANDARD_GOOD + (1 - p_good[n]) * PASS_PRELIM_PASS_STANDARD_BAD;

                p_fail_standard[n] = p_good[n] * FAIL_STANDARD_GOOD + (1 - p_good[n]) * FAIL_STANDARD_BAD;
                p_pass_standard[n] = p_good[n] * PASS_STANDARD_GOOD + (1 - p_good[n]) * PASS_STANDARD_BAD;

                p_good_pass_prelim_pass_standard[n] = p_good[n] * PASS_PRELIM_PASS_STANDARD_GOOD / (p_good[n] * PASS_PRELIM_PASS_STANDARD_GOOD + (1 - p_good[n]) * PASS_PRELIM_PASS_STANDARD_BAD);
                p_good_pass_standard[n] = p_good[n] * PASS_STANDARD_GOOD / (p_good[n] * PASS_STANDARD_GOOD + (1 - p_good[n]) * PASS_STANDARD_BAD);
            }
            memset(cache, 0, sizeof cache);
        }

        if (i < SKIPS) {
            interactor->reject();
        } else if (interactor->selected.empty() && i + 10 < N) {
            interactor->prelim();
        } else if (i < PASS && i + 10 < N) {
            interactor->reject();
        } else {
            action = -1;
            const int mn = min(interactor->min_selected(), MN_RANGE);
            const int inv_mx = min(N - interactor->max_selected() - 1, MX_RANGE);
            float optimal_score = expectimax(i, interactor->time_spent / 5, interactor->selected.size(), mn, inv_mx, action);
            //cerr << i << ' ' << optimal_score << ' ' << interactor->time_spent / 5 << ' ' << interactor->selected.size() << endl;

            if (action == 0) {
                interactor->reject();
            } else if (action == 1) {
                interactor->prelim();
            } else if (action == 2) {
                interactor->full();
            } else if (action == 3) {
                interactor->accept();
            }
        }
    }
    return interactor->score();
}

constexpr int TESTS = 0;
array<double, 8> stats_of(const array<double, TESTS>& scores) {
    double sum = 0;
    for (double x: scores) {
        sum += x;
    }
    double mean = sum / scores.size();

    double variance = 0;
    for (double x: scores) {
        variance += (x - mean) * (x - mean);
    }
    double stddev = sqrt(variance / scores.size());
    double stderror = sqrt(variance) / scores.size();

    array<double, TESTS> tmp(scores);
    sort(tmp.begin(), tmp.end());
    // quartiles are approximate, should be good enough
    return {mean, stddev, stderror, *min_element(scores.begin(), scores.end()), tmp[TESTS / 4], tmp[TESTS / 2], tmp[3 * TESTS / 4], *max_element(scores.begin(), scores.end())};
}

string to_string(const array<double, 8>& arr) {
    string s = to_string(arr[0]);
    for (int i = 1; i < (int)arr.size(); ++i) s += ", " + to_string(arr[i]);
    return s;
}

array<double, TESTS> scores, mn, second, mx, hires, times;  // declaring locally causes crash on my computer
void test() {
    N = 100;
    for (int t = 0; t < TESTS; ++t) {
        unique_ptr<Interactor> interactor = make_unique<SelfInteractor>(N);
        scores[t] = strategy(interactor);
        mn[t] = interactor->min_selected();
        second[t] = interactor->selected[1];
        mx[t] = interactor->max_selected();
        hires[t] = interactor->selected.size();
        times[t] = interactor->time_spent / 5;
        if ((t * 10) % TESTS == 0) cout << t << endl;
    }
    cout << fixed << setprecision(6);
    cout << "TESTS = " << TESTS << endl;
    cout << "MAX_TIME = " << MAX_TIME << ", MAX_HIRES = " << MAX_HIRES << ", MN_RANGE = " << MN_RANGE << ", MX_RANGE = " << MX_RANGE << endl;
    cout << "SKIPS = " << SKIPS << ", PASS = " << PASS << ", " << "N_OFFSET = " << N_OFFSET << endl;
    cout << "score mean, stddev, stderr, min, q1, med, q3, max: " << to_string(stats_of(scores)) << endl;
    cout << "min   mean, stddev, stderr, min, q1, med, q3, max: " << to_string(stats_of(mn)) << endl;
    cout << "2nd   mean, stddev, stderr, min, q1, med, q3, max: " << to_string(stats_of(second)) << endl;
    cout << "max   mean, stddev, stderr, min, q1, med, q3, max: " << to_string(stats_of(mx)) << endl;
    cout << "hires mean, stddev, stderr, min, q1, med, q3, max: " << to_string(stats_of(hires)) << endl;
    cout << "times mean, stddev, stderr, min, q1, med, q3, max: " << to_string(stats_of(times)) << endl;
    /*
    TESTS = 10000
    MAX_TIME = 900, MAX_HIRES = 22, MN_RANGE = 59, MX_RANGE = 9
    SKIPS = 1, PASS = 59, N_OFFSET = 59
    score mean, stddev, stderr, min, q1, med, q3, max: 38.538634, 66.856497, 0.668565, 0.000000, 0.000000, 16.285439, 52.973755, 947.368408
    min   mean, stddev, stderr, min, q1, med, q3, max: 15.721000, 9.834234, 0.098342, 1.000000, 8.000000, 14.000000, 22.000000, 60.000000
    2nd   mean, stddev, stderr, min, q1, med, q3, max: 74.983400, 4.460709, 0.044607, 64.000000, 72.000000, 75.000000, 78.000000, 94.000000
    max   mean, stddev, stderr, min, q1, med, q3, max: 97.685700, 1.810336, 0.018103, 84.000000, 97.000000, 98.000000, 99.000000, 99.000000
    hires mean, stddev, stderr, min, q1, med, q3, max: 9.727200, 2.579415, 0.025794, 5.000000, 8.000000, 10.000000, 11.000000, 19.000000
    times mean, stddev, stderr, min, q1, med, q3, max: 352.208900, 115.062409, 1.150624, 69.000000, 272.000000, 348.000000, 432.000000, 796.000000
    */
}

int main() {
    if (TESTS != 0) {
        test();
        return 0;
    }

    cin >> N;
    strategy(make_unique<GraderInteractor>(N));
}

