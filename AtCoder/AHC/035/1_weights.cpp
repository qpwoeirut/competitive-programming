#include <bits/stdc++.h>

using namespace std;

const int N = 6;
const int M = 15;
const int T = 10;
const int K = 2 * N * (N - 1);

int X[K][M];
int A[N][N];

using weight_t = array<array<array<double, M>, N>, N>;
weight_t weight = {{
    {{
        {{0.1148226667529742, 0.2326876536910960, 0.0264279005211982, 0.0152355667127706, 0.0160080217411673, 0.0252970991902854, 0.1176718968768141, 0.0252847630484586, 0.0166044914242490, 0.0621778150348205, 0.0890647873681013, 0.0074522432793657, 0.1448723783375099, 0.0941502763227629, 0.0122424396984261}},
        {{0.0001695871941956, 0.0000144901696922, 0.0000722593636567, 0.0094205779612542, 0.1021691160287978, 0.0000053111856989, 0.0000475008394317, 0.8874921650352440, 0.0000305282900291, 0.0001345609175440, 0.0000289926042988, 0.0000614921201650, 0.0000903391510435, 0.0002263876790022, 0.0000366914599462}},
        {{0.0061265868959512, 0.0291896732197758, 0.0181590789659521, 0.0012490222249000, 0.0061745490094292, 0.8404948372337988, 0.0088458761369313, 0.0015662799188305, 0.0012366256014522, 0.0065445344397917, 0.0053865093800330, 0.0141932868081927, 0.0262072723530149, 0.0053869558776000, 0.0292389119343467}},
        {{0.0748678850943840, 0.1578145704341806, 0.0072954297833142, 0.0697096132429474, 0.0884790236580136, 0.0087887572039054, 0.0157517983036921, 0.1077157008646314, 0.0063060370468265, 0.0155063454966148, 0.1277328084374152, 0.1620406690792457, 0.0881644098269404, 0.0427418040148640, 0.0270851475130245}},
        {{0.0007568235916434, 0.0035682922407922, 0.0005545077120117, 0.0017717406674164, 0.0037600440707074, 0.0073204614077350, 0.8075955409031234, 0.0004345039617304, 0.0000734408878780, 0.0009644094484321, 0.0010256391913052, 0.0068385663633120, 0.0068848193572828, 0.0045339284808848, 0.1539172817157456}},
        {{0.0341029078014197, 0.1856093130616437, 0.0363094833208733, 0.1948181583851828, 0.0256926971098560, 0.0868428499841507, 0.0401871215838533, 0.0216315976540933, 0.0598454298064847, 0.1207136308945670, 0.0091104710167822, 0.0288667120736435, 0.0806606415126668, 0.0534241741206655, 0.0221848116741171}}
    }},
    {{
        {{0.0003758728260439, 0.0000019641793082, 0.0001568386080101, 0.0003011368028048, 0.0003139742481541, 0.0616997094268774, 0.0001035529966428, 0.0002631759424376, 0.0005449927437776, 0.0002531851431493, 0.0004503920176058, 0.9346546145784415, 0.0004490862131389, 0.0003563053554782, 0.0000751989181298}},
        {{0.0000044805835790, 0.0068173633594258, 0.0000655754191764, 0.0000287277380331, 0.0000114152863839, 0.0000101569685116, 0.1047224684963937, 0.0000395840222745, 0.0000067604532584, 0.0000346420358479, 0.0000138959117463, 0.0000388195393969, 0.0000480207352636, 0.0000055947055024, 0.8881524947452065}},
        {{0.0042256142720755, 0.0029794194100327, 0.0098823990746851, 0.0105412615857191, 0.0092951215088158, 0.0094431127213127, 0.0015295804742241, 0.0215432339809860, 0.8920679346591688, 0.0085620255277413, 0.0039028510695328, 0.0012666367802831, 0.0051143475699889, 0.0012872939108623, 0.0183591674545718}},
        {{0.0088241043152386, 0.0067716880498823, 0.0077136793702671, 0.0007665389470057, 0.0003919233533263, 0.0012273481237045, 0.0020659783848113, 0.0036776686516907, 0.0050060670509618, 0.0057050974787882, 0.0018685995894995, 0.0124875148186476, 0.0104627133933675, 0.9274783049206922, 0.0055527735521165}},
        {{0.0281254710735138, 0.0785429703132117, 0.1036420910242918, 0.0541955409241638, 0.0554103295918430, 0.0003517649924515, 0.0379452716370364, 0.1504608898731308, 0.0469379975041206, 0.1638104651623305, 0.0353412122509098, 0.0051005032144549, 0.1258656483601114, 0.0378431134744339, 0.0764267306039964}},
        {{0.0596587906195569, 0.1685559019079124, 0.0789193883035214, 0.0086180803733405, 0.0631442969242267, 0.0022898295014911, 0.0078126853353710, 0.0293338815883019, 0.0263197347085922, 0.1523973750308775, 0.1579259845586262, 0.0203179851672945, 0.0540467080487661, 0.1233675396745279, 0.0472918182575936}}
    }},
    {{
        {{0.0038792589383114, 0.0016326458353620, 0.0002974129578979, 0.0037221050570635, 0.0061710355354053, 0.0009484519986038, 0.0027547264848500, 0.0042804627926793, 0.0195766271878245, 0.9293673069832705, 0.0017639627563108, 0.0012059895540879, 0.0047519154478045, 0.0094153727986007, 0.0102327256719279}},
        {{0.4259462569450584, 0.0061884265142077, 0.0010067105462633, 0.0149774987605049, 0.0460974978721515, 0.0184776194616260, 0.0385669135505562, 0.0383300439772325, 0.1227493415036506, 0.0685778232048990, 0.0400592861919554, 0.0254513672647623, 0.0594611617375441, 0.0759060526018014, 0.0182039998677868}},
        {{0.0182482589572145, 0.0113643718816301, 0.8686311311578510, 0.0136157891408556, 0.0017358359582364, 0.0007231272690248, 0.0155512506324741, 0.0123033230851581, 0.0000499269664673, 0.0001604652327449, 0.0274789918471923, 0.0023131228860081, 0.0201715913939278, 0.0066859284700597, 0.0009668851211553}},
        {{0.0138140892743330, 0.0070165644207429, 0.0013980614641547, 0.0008932697063205, 0.8829339302486415, 0.0017277211427926, 0.0171707409429231, 0.0063646118871935, 0.0215854004073004, 0.0156634283301006, 0.0108402057468271, 0.0093517305976767, 0.0017528817276807, 0.0012479937557894, 0.0082393703475232}},
        {{0.0634654792315181, 0.0014031565320417, 0.0476702459722300, 0.0542736707260726, 0.0145638728320087, 0.0469756227772425, 0.2753420781141667, 0.0709269687164669, 0.0082865554646105, 0.0865796501037950, 0.1496003640578029, 0.0830719940984775, 0.0147432741674619, 0.0053876511205349, 0.0777094160855701}},
        {{0.0537625112409996, 0.0407689129047317, 0.0266291448631808, 0.0469294387161140, 0.0418546271201046, 0.4484820263124811, 0.0617920723468506, 0.0098389295137740, 0.0362069705623424, 0.0312600891065674, 0.0310739296038923, 0.0584444753982496, 0.0245928267373195, 0.0382906741000222, 0.0500733714733701}}
    }},
    {{
        {{0.0366056174543600, 0.1382208885663114, 0.0524477825761007, 0.0139457736562026, 0.0086947314345898, 0.0174207309032926, 0.0006198143299652, 0.0091140169354955, 0.1476873808468527, 0.1053634712776720, 0.1275237185021856, 0.0402746414675779, 0.0035551253057595, 0.2925675170528785, 0.0059587896907560}},
        {{0.0014505880467192, 0.0020856048685110, 0.0039366806807865, 0.0023647754436793, 0.0058928353317876, 0.0181603968235667, 0.0142940501264975, 0.0081809848540717, 0.0030720605624981, 0.0005345945314663, 0.8832158450344142, 0.0050739415986574, 0.0077302879555536, 0.0198670799136921, 0.0241402742280986}},
        {{0.0054746645123015, 0.0060247029692071, 0.0049589517713620, 0.9279675945010707, 0.0043679904567364, 0.0061266236601086, 0.0002603907289947, 0.0074331762422738, 0.0053189842124815, 0.0074578254811800, 0.0013663737166325, 0.0023740213780698, 0.0033712014577128, 0.0056708762202765, 0.0118266226915923}},
        {{0.0054231771471820, 0.0016054637333981, 0.0008153793280373, 0.0051058515038579, 0.0007804795069051, 0.0093201193272103, 0.0124590314921545, 0.0010974960125478, 0.0139353870046766, 0.0001053637883702, 0.0040131608295013, 0.0184795493942003, 0.9220382782771509, 0.0044848717896329, 0.0003363908651747}},
        {{0.0026134754759485, 0.0101027880405303, 0.0019523656173386, 0.0091200250405887, 0.0116046042771523, 0.9011751329795861, 0.0075579185578022, 0.0081911356577959, 0.0000983283880661, 0.0035132981236983, 0.0007418288658529, 0.0051820175490774, 0.0037730607676772, 0.0308090061029676, 0.0035650145559182}},
        {{0.1309742369354250, 0.0058871110628598, 0.0966679540668817, 0.1589663855960202, 0.0123886857895327, 0.0009188874824926, 0.0617546445010996, 0.0168062774577023, 0.1061305849136413, 0.0085754165383016, 0.1732516827779968, 0.0891182606627529, 0.0324058454127898, 0.0729025879689410, 0.0332514388335627}}
    }},
    {{
        {{0.1344234472993691, 0.0840684261109836, 0.0421498442677462, 0.0008068222789867, 0.0128268045428684, 0.0132580605001858, 0.0786548573261647, 0.0928729009641683, 0.0614517321980369, 0.0675540785522301, 0.0208975295227911, 0.1286806130606243, 0.0475957778895596, 0.1443221173490459, 0.0704369881372394}},
        {{0.0910918704755205, 0.1346078576616229, 0.0957675932660077, 0.0201708799271913, 0.0360210795364203, 0.0223196214825724, 0.1407250779208551, 0.1170060149064778, 0.0948458748957186, 0.0392097605561407, 0.0000700466615812, 0.0652291919395114, 0.0473719202865999, 0.0588419178439137, 0.0367212926398663}},
        {{0.0008748970228524, 0.0007127899217949, 0.0080552440734762, 0.0031857854527752, 0.0032545232251773, 0.0031650982523858, 0.0203261615625436, 0.0016485037815493, 0.0021296404229605, 0.0071849948325553, 0.0135631809825595, 0.8920106155821386, 0.0124291272824020, 0.0137369128585597, 0.0177225247462698}},
        {{0.0031159183683807, 0.9078706339348428, 0.0066546185201723, 0.0073164865313137, 0.0006034275150280, 0.0032289490318411, 0.0147227234967233, 0.0053476831706447, 0.0032755143459747, 0.0188836269429620, 0.0059323847549233, 0.0038821155564223, 0.0079670900341350, 0.0059248090865864, 0.0052740187100494}},
        {{0.0165616720146813, 0.0434526772184443, 0.0896973504473731, 0.1003188970313112, 0.0911924208332158, 0.0029357966359821, 0.0834256203883181, 0.0941497420405248, 0.2314678537428337, 0.0567240219246661, 0.0089449556494735, 0.0231259353748083, 0.0650797538738764, 0.0239280796027487, 0.0689952232217424}},
        {{0.0048906145194877, 0.0017619716002779, 0.0254644564096802, 0.0229940211266217, 0.0055355617289647, 0.7584121412825778, 0.0032535853135292, 0.0139851189479932, 0.0349508801970375, 0.0081441384298878, 0.0280317534041069, 0.0093778688447018, 0.0225288536989117, 0.0472164431464726, 0.0134525913497495}}
    }},
    {{
        {{0.0625313746348757, 0.1161149113798752, 0.1006455231170121, 0.0758108311842178, 0.0857734082326355, 0.0575521293778573, 0.0299415481430441, 0.0391220246791019, 0.0238664015311861, 0.1073161589231028, 0.0240329338375887, 0.0501123887181399, 0.2049600414760990, 0.0218018829056384, 0.0004184418596256}},
        {{0.0628460620053541, 0.0928039026922589, 0.1054091010932400, 0.0176496674295269, 0.1373178281029551, 0.0518632418930349, 0.0098530859718305, 0.0393889142220937, 0.0263070537357624, 0.0764239081673504, 0.1189329801636169, 0.1851060039405527, 0.0253718436004880, 0.0365271126266931, 0.0141992943552425}},
        {{0.0561018160327912, 0.0750064609351691, 0.1065352548145686, 0.0793148036931885, 0.1107682393166770, 0.0454640355116178, 0.0078308001860136, 0.0145795005814401, 0.0482640561572151, 0.1693527271759644, 0.0782879675582096, 0.0025854074099662, 0.0706995070927767, 0.0786470074191143, 0.0565624161152878}},
        {{0.0951285051484387, 0.0402804180192654, 0.0642975903078647, 0.1877933003380284, 0.0472030974881071, 0.0186979926492321, 0.0136706305821133, 0.0422531974657107, 0.0769578287788761, 0.0206577735080426, 0.0508377260845707, 0.0503263523657057, 0.0563358941100608, 0.1149407967057603, 0.1206188964482236}},
        {{0.0152124499751846, 0.0125480651967323, 0.0526253824567162, 0.0961333943005496, 0.0820423087969456, 0.0099686477352146, 0.0427938050422085, 0.0630744016039217, 0.1782579884391645, 0.0694255945091535, 0.0007201901681513, 0.0158543114208576, 0.1017080602056614, 0.0826773818677421, 0.1769580182817963}},
        {{0.0893386506272942, 0.0473446806313251, 0.0135433839566112, 0.0648685650847809, 0.0105415314900340, 0.0000243307739733, 0.0148665019672311, 0.1011709185432317, 0.2579629149963807, 0.0490198786943889, 0.0120133185279061, 0.0859316585925100, 0.1046626420063828, 0.1081787706801578, 0.0405322534277923}}
    }}
}};
double eval(const int k, const int r, const int c) {
    double score = 0;
    for (int i=0; i<M; ++i) {
        score += weight[r][c][i] * X[k][i];
    }
    if (r == 0 || r == N - 1) score *= 0.9;
    if (c == 0 || c == N - 1) score *= 0.9;
    return score;
}

using opt_t = tuple<double, int, int, int>;

void solve(void getX(), void outputA()) {
    opt_t options[K * N * N];

    for (int t=0; t<T; ++t) {
        getX();

        for (int k=0; k<K; ++k) {
            for (int r=0; r<N; ++r) {
                for (int c=0; c<N; ++c) {
                    options[k * N * N + r * N + c] = {eval(k, r, c), k, r, c};
                }
            }
        }
        sort(options, options + K * N * N, greater<opt_t>());

        bitset<N*N> used;
        bitset<N*N> filled;
        for (int i=0; i<K*N*N; ++i) {
            auto [score, k, r, c] = options[i];
            if (used[k] || filled[r * N + c]) continue;

            used[k] = true;
            filled[r * N + c] = true;
            A[r][c] = k;
        }
        
        outputA();
    }
}

void readX() {
    for (int i=0; i<K; ++i) {
        for (int j=0; j<M; ++j) {
            cin >> X[i][j];
        }
    }
}
void printA() {
    for (int i=0; i<N; ++i) {
        for (int j=0; j<N; ++j) {
            cout << A[i][j] << (j+1 < N ? ' ' : '\n');
        }
    }
    cout.flush();
}

namespace Trainer {
    // stolen from https://atcoder.jp/contests/ahc031/submissions/51940007
    using uint = unsigned int;
    using ull = unsigned long long;
    class rngen {
    public:
        rngen() {}

        // to avoid bugs
        rngen(const rngen&) = delete;

        rngen& operator=(const rngen&&) = delete;

        rngen(int s) {
            seed(s);
        }

        void seed(int s) {
            state = s + INCR;
            next32();
        }

        int next_int() {
            return next31();
        }

        int next_int(int mod) {
            assert(mod > 0);
            return (int) ((ull) next31() * mod >> 31);
        }

        int next_int(int min, int max) {
            return min + next_int(max - min + 1);
        }

        double next_float() {
            return (double) next31() / 0x80000000;
        }

        double next_normal() {
            return sqrt(-2 * log(next_float())) * cos(6.283185307179586 * next_float());
        }

    private:
        static constexpr ull MULT = 0x8b46ad15ae59daadull;
        static constexpr ull INCR = 0xf51827be20401689ull;
        ull state = (ull) chrono::duration_cast<chrono::nanoseconds>(chrono::system_clock::now().time_since_epoch()).count();

        uint next32() {
            uint r = (uint) (state >> 59);
            state = state * MULT + INCR;
            state ^= state >> 18;
            uint t = (uint) (state >> 27);
            return t >> r | t << (-r & 31);
        }

        int next31() {
            return (int) (next32() & 0x7fffffff);
        }
    };
    
    rngen rng;
    int initX() {
        double tmp[M];
        for (int k=0; k<K; ++k) {
            double p_denom = 0;
            for (int i=0; i<M; ++i) {
                tmp[i] = abs(rng.next_normal());
                p_denom += tmp[i] * tmp[i];
            }
            const double p = 100 / sqrt(p_denom);
            for (int i=0; i<M; ++i) {
                X[k][i] = round(p * tmp[i]);
            }
        }
        int max_score = 0;
        for (int i=0; i<M; ++i) {
            int mx = 0;
            for (int k=0; k<K; ++k) {
                mx = max(mx, X[k][i]);
            }
            max_score += mx;
        }
        return max_score;
    }

    void combine(int a[], int b[], int out[]) {
        const int rand = rng.next_int();
        for (int i=0; i<M; ++i) {
            out[i] = (rand >> i) & 1 ? a[i] : b[i];
        }
    }

    void calcX() {
        int X_new[K][M];
        int i = 0;
        for (int r=0; r<N; ++r) {
            for (int c=0; c<N; ++c) {
                if (r > 0) {
                    combine(X[A[r - 1][c]], X[A[r][c]], X_new[i++]);
                }
                if (c > 0) {
                    combine(X[A[r][c - 1]], X[A[r][c]], X_new[i++]);
                }
            }
        }
        assert(i == K);
        for (int k=0; k<K; ++k) {
            for (int m=0; m<M; ++m) {
                X[k][m] = X_new[k][m];
            }
        }
    }
    void noop(){}

    void normalize(array<double, M>& arr) {
        double s = 0;
        for (int i=0; i<M; ++i) s += arr[i];
        for (int i=0; i<M; ++i) arr[i] /= s;
    }
    void init(weight_t& w) {
        for (int r=0; r<N; ++r) {
            for (int c=0; c<N; ++c) {
                for (int i=0; i<M; ++i) {
                    w[r][c][i] = rng.next_int(2);
                }
                normalize(w[r][c]);
            }
        }
    }
    void mutate(weight_t& w) {
        const int r = rng.next_int(N), c = rng.next_int(N), i = rng.next_int(M);
        w[r][c][i] += rng.next_float() * M;
        normalize(w[r][c]);
        if (r > 0) {
            w[r - 1][c][i] *= rng.next_float();
            normalize(w[r - 1][c]);
        }
        if (c > 0) {
            w[r][c - 1][i] *= rng.next_float();
            normalize(w[r][c - 1]);
        }
        if (c < N - 1) {
            w[r][c + 1][i] *= rng.next_float();
            normalize(w[r][c + 1]);
        }
        if (r < N - 1) {
            w[r + 1][c][i] *= rng.next_float();
            normalize(w[r + 1][c]);
        }
    }
    double end_score(int max_score) {
        int best_seed = 0;
        for (int k=0; k<K; ++k) {
            int value = 0;
            for (int i=0; i<M; ++i) value += X[k][i];
            best_seed = max(best_seed, value);
        }
        return (double)(best_seed) / max_score;
    }

    const int GEN = 1;
    const int CHILD = 20;
    const int GAMES = 100;
    void train() {
        pair<double, weight_t> best[GEN];
        pair<double, weight_t> cur[GEN * CHILD];
        for (int i=0; i<GEN; ++i) {
            init(best[i].second);
        }

        while (true) {
            for (int i=0; i<GEN; ++i) {
                cerr << "i " << i << endl;
                for (int j=0; j<CHILD; ++j) {
                    cur[i * CHILD + j].first = 0;
                    cur[i * CHILD + j].second = best[i].second;
                    mutate(cur[i * CHILD + j].second);
                    weight = cur[i * CHILD + j].second;

                    for (int g=0; g<GAMES; ++g) {
                        const int max_score = initX();
                        solve(noop, calcX);
                        cur[i * CHILD + j].first += end_score(max_score);
                    }
                }
            }
            sort(cur, cur + GEN * CHILD, greater<pair<int, weight_t>>());
            copy(cur, cur + GEN, best);

            cout << fixed << setprecision(16) << best[0].first * 300.0 / GAMES << endl;
            for (int r=0; r<N; ++r) {
                cout << "{{";
                for (int c=0; c<N; ++c) {
                    cout << "{{";
                    for (int i=0; i<M; ++i) {
                        if (i) cout << ", ";
                        cout << best[0].second[r][c][i];
                    }
                    cout << "}},\n";
                }
                cout << "}},\n";
            }
        }
    }
}

int main() {
    cin.tie(0)->sync_with_stdio(0);

    Trainer::train(); return 0;

    int _N, _M, _T;
    cin >> _N >> _M >> _T;
    assert(N == _N && M == _M && T == _T);

    solve(readX, printA);
}
